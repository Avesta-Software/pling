
from binascii import hexlify
from collections import Iterable
from copy import copy

from pling.bitmath import ones_complement_add
from pling.utils import defer_property

class Ipv4RawPacket:
    fields = [
        # Offset 0
        ["version", 4],
        ["ihl", 4],

        # Offset 1
        ["dscp", 6],
        ["ecn", 2],

        # Offset 2
        ["total_length", 16],

        # Offset 4
        ["identification", 16],

        # Offset 6
        ["flags", 3],
        ["fragment_offset", 13],

        # Offset 8
        ["time_to_live", 8],
        ["protocol", 8],

        # Offset 10
        ["header_checksum", 16],

        # Offset 12
        ["source_ip", 32],

        # Offset 16
        ["destination_ip", 32]
    ]

    @classmethod
    def from_bytes(cls, b):
        """Parses the raw bytes and returns a Ipv4RawPacket object"""
        assert len(b) >= 20

        p = Ipv4RawPacket()

        integers = []

        for b1, b2, b3, b4 in [b[x:x + 4] for x in range(0, 20, 4)]:
            integers.append((b1 << 24) + (b2 << 16) + (b3 << 8) + b4)

        integer_counter = 0
        bit_counter = 0

        for field, bits in Ipv4RawPacket.fields:
            i = integers[integer_counter]

            mask = 1

            for x in range(0, bits - 1):
                mask = (mask << 1) + 1

            bit_counter += bits

            value = (i >> (32 - bit_counter)) & mask

            setattr(p, field, value)

            if bit_counter >= 32:
                bit_counter = 0
                integer_counter += 1

        p.payload = b[20:]

        return p

    def __init__(self):
        # Initializes all fields to 0
        for field, bits in self.fields:
            setattr(self, field, 0)

        self.payload = bytes()

        # Sensible defaults
        self.version = 4
        self.ihl = 5
        self.total_length = 20

    def __repr__(self):
        clsname = type(self).__name__

        checksum = hex(self.generate_header_checksum())[2:]
        checksum = checksum.upper().rjust(4, "0")

        return '<{} header_checksum="0x{}">'.format(clsname, checksum)

    def __eq__(self, other):
        if type(self) != type(other):
            return False

        for field, bits in self.fields:
            if getattr(self, field) != getattr(other, field):
                return False

        if self.payload != other.payload:
            return False

        return True

    def __bytes__(self):
        """Returns a byte representation of the packet"""
        return self.header_bytes() + self.payload

    def __iter__(self):
        """Returns a generator yielding key/value pairs

        Makes it possible to +dict(package)+ for a dict representation
        """
        return ((field, getattr(self, field)) for (field, _) in self.fields)

    def header_bytes(self, zero_checksum=False):
        """Returns the header as bytes

        Parameters:
            zero_checksum: If true, returns the bytes with the header checksum
                set to 0
        """
        b = bytearray()

        counter = 0
        integer = 0

        # The values are packed into 4-byte integers, since the largest
        # fixed-size header fields are 4-byte IP addresses. After that, they are
        # added to the byte array as 4 bytes.
        for field, bits in self.fields:
            assert counter <= 32, "Bit counter somehow got over 32!"

            if counter < 32:
                if field == "header_checksum" and zero_checksum:
                    value = 0
                else:
                    value = getattr(self, field)

                integer += (value << (32 - bits - counter))
                counter += bits

            if counter == 32:
                b.append((integer >> 24) & 255)
                b.append((integer >> 16) & 255)
                b.append((integer >> 8) & 255)
                b.append(integer & 255)

                integer = 0
                counter = 0

        return bytes(b)

    def update_header_checksum(self):
        """Calculates and updates the header checksum field"""
        self.header_checksum = self.generate_header_checksum()

    def update_total_length(self):
        """Updates the total_length field to the correct value"""
        self.total_length = len(bytes(self))

    def generate_header_checksum(self, omit_checksum=True):
        """Generates and returns the header checksum

        Parameters:
            omit_checksum: When True, returns the checksum with the header
                checksum bits omitted (set to 0). When verifying a checksum,
                that's not desirable.
        """
        b = self.header_bytes(zero_checksum=omit_checksum)

        # The checksum is generated by adding together the header bytes as
        # 16-bit words.
        pairs = ((b[x], b[x + 1]) for x in range(0, len(b), 2))
        words = ((b1 << 8) + b2 for b1, b2 in pairs)

        checksum = sum(words)

        # Carry the overflow
        while checksum > 65535:
            checksum = (checksum & 65535) + (checksum >> 16)

        # Flip the checksum
        checksum ^= 65535

        return checksum

    def verify_checksum(self):
        """Returns True if the checksum checks out, otherwise False"""
        return self.generate_header_checksum(omit_checksum=False) == 0

    def diagram(self, with_lines=False, with_captions=False):
        """Returns a pretty diagram representing the packet

        Parameters:
            with_lines: Display lines pointing out the fields
            with_captions: Display captions explaining the lines
        """
        out = []

        row = 0
        col = 0
        byte_counter = 0

        if with_captions:
            out.append("1: Version  2: IHL  3: DSCP  4: ECN  5: Total Length\n")
            out.append("6: Identification  7: Flags  8: Fragment Offset\n")
            out.append("9: Time To Live  10: Protocol  11: Header Checksum\n")
            out.append("12: Source IP  13: Destination IP\n")

            if len(self.payload) > 0:
                out.append("14: Payload\n")

            out.append("\n")

        hb = len(self.header_bytes())

        for byte in bytes(self):
            if with_lines:
                # Version, IHL, DSCP, ECN and Total Length
                if col == 0 and row == 0:
                    out.append(" 1    2      3     4     5\n")
                    out.append("┌┴─┐ ┌┴─┐   ┌┴────┐├┐   ")
                    out.append("┌┴──────────────────┐\n")

                # Identification, Flags and Fragment Offset
                if col == 0 and row == 1:
                    out.append(" 6                       7  8\n")
                    out.append("┌┴──────────────────┐   ")
                    out.append("┌┴┐┌┴───────────────┐\n")

                # Time To Live, Protocol and Header Checksum
                if col == 0 and row == 2:
                    out.append(" 9           10          11\n")
                    out.append("┌┴──────┐   ┌┴──────┐   ")
                    out.append("┌┴──────────────────┐\n")

                # Source IP
                if col == 0 and row == 3:
                    out.append(" 12\n")
                    out.append("┌┴──────────────────────")
                    out.append("────────────────────┐\n")

                # Destination IP
                if col == 0 and row == 4:
                    out.append(" 13\n")
                    out.append("┌┴──────────────────────")
                    out.append("────────────────────┐\n")

                # Payload
                if byte_counter == hb:
                    out.append(" 14\n")
                    out.append("┌┴──────────────────────")
                    out.append("────────────────────┐\n")

            byte = bin(byte)[2:].rjust(8, "0")
            first = byte[:4]
            last = byte[4:]

            out.append(first)
            out.append(" ")
            out.append(last)

            if col == 3:
                out.append("\n")
                col = 0
                row += 1
            else:
                out.append("   ")
                col += 1

            byte_counter += 1

        return "".join(out).strip()

class Ipv4Packet:
    """This class represents an IPv4 packet"""

    # Source: http://www.iana.org/assignments
    #         /protocol-numbers/protocol-numbers.xhtml
    PROTOCOLS = {
        "ICMP": 1,
        "TCP": 6,
        "UDP": 17
    }

    PROTOCOLS_INVERTED = dict(zip(PROTOCOLS.values(), PROTOCOLS.keys()))

    def __init__(self):
        self.raw = Ipv4RawPacket()

    # The version can only be 4, so it might as well be read-only
    version = property(lambda self: self.raw.version)

    def get_flags(self):
        """Returns the flags represented as a set of strings

        Enables syntax like this:

        >>> if "MF" in packet.flags:
        >>>     print('The "More Fragments" bit is set')
        """

        if self.raw.flags not in [0, 1, 2, 3]:
            raise ValueError("Invalid raw flags: {}".format(self.raw.flags))

        flags = set()

        if (self.raw.flags & 0b010) > 0:
            flags.add("DF")

        if (self.raw.flags & 0b001) > 0:
            flags.add("MF")

        return frozenset(flags)

    def set_flags(self, flags):
        """The flags must either be an iterable or an integer"""

        if isinstance(flags, int):
            if flags not in (0, 1, 2, 3):
                raise ValueError("Invalid flags: {}".format(flags))

            self.raw.flags = flags

        elif isinstance(flags, Iterable):
            valid_flags = {"DF", "MF"}
            flags = set(flags)
            invalid_flags = flags.difference(valid_flags)

            if len(invalid_flags) > 0:
                raise ValueError("Invalid flags: {}".format(invalid_flags))

            raw_flags = 0

            if "DF" in flags:
                raw_flags += 0b010

            if "MF" in flags:
                raw_flags += 0b001

            self.raw.flags = raw_flags

        else:
            msg = "Expected flags to be int or iterable, got: {}"
            raise TypeError(msg.format(type(flags).__name__))

    flags = property(get_flags, set_flags)

    def get_protocol(self):
        if self.raw.protocol not in self.PROTOCOLS.values():
            raise ValueError("Unrecognized protocol in raw packet")

        return self.PROTOCOLS_INVERTED[self.raw.protocol]

    def set_protocol(self, value):
        if isinstance(value, str):
            if value not in self.PROTOCOLS:
                raise ValueError("Unrecognized protocol name: {}".format(value))

            self.raw.protocol = self.PROTOCOLS[value]

        elif isinstance(value, int):
            if value not in self.PROTOCOLS.values():
                msg = "Unrecognized protocol number: {}".format(value)
                raise ValueError(msg)

            self.raw.protocol = value

        else:
            msg = "Expected protocol to be str or int, got: {}"
            raise TypeError(msg.format(type(value).__name__))

    protocol = property(get_protocol, set_protocol)

    ihl             = defer_property("raw", "ihl")
    dscp            = defer_property("raw", "dscp")
    ecn             = defer_property("raw", "ecn")
    total_length    = defer_property("raw", "total_length")
    fragment_offset = defer_property("raw", "fragment_offset")
    time_to_live    = defer_property("raw", "time_to_live")
    header_checksum = defer_property("raw", "header_checksum")
    source_ip       = defer_property("raw", "source_ip")
    destination_ip  = defer_property("raw", "destination_ip")

    payload         = defer_property("raw", "payload")
